#include <stdio.h>
#include <stdlib.h>
#include <omp.h>

// ===============================================
// 1️⃣ PARALLEL + SINGLE
// ===============================================
void fib_single(int n) {
    int *a = malloc(n * sizeof(int));
    a[0] = 0;
    a[1] = 1;

    double st = omp_get_wtime();
    omp_set_num_threads(2);

    #pragma omp parallel
    {
        #pragma omp single
        {
            printf("\n[SINGLE] Compute Thread: %d\n", omp_get_thread_num());
            for (int i = 2; i < n; i++)
                a[i] = a[i - 2] + a[i - 1];
        }

        #pragma omp single
        {
            printf("[SINGLE] Display Thread: %d\n", omp_get_thread_num());
            printf("Fibonacci: ");
            for (int i = 0; i < n; i++)
                printf("%d ", a[i]);
            printf("\n");
        }
    }

    double et = omp_get_wtime();
    printf("[SINGLE] Time: %lf ms\n", (et - st) * 1000);
    free(a);
}

// ===============================================
// 2️⃣ PARALLEL + SECTIONS
// (No barrier — invalid inside sections)
// ===============================================
void fib_sections(int n) {
    int *a = malloc(n * sizeof(int));
    a[0] = 0;
    a[1] = 1;

    double st = omp_get_wtime();
    omp_set_num_threads(2);

    #pragma omp parallel
    {
        #pragma omp sections
        {
            #pragma omp section
            {
                printf("\n[SECTIONS] Compute Thread: %d\n", omp_get_thread_num());
                for (int i = 2; i < n; i++)
                    a[i] = a[i - 2] + a[i - 1];
            }

            #pragma omp section
            {
                // Just prints — may run early
                printf("[SECTIONS] Display Thread: %d\n", omp_get_thread_num());
                printf("Fibonacci (may show zeros if race): ");
                for (int i = 0; i < n; i++)
                    printf("%d ", a[i]);
                printf("\n");
            }
        }
    }

    double et = omp_get_wtime();
    printf("[SECTIONS] Time: %lf ms\n", (et - st) * 1000);
    free(a);
}

// ===============================================
// 3️⃣ PARALLEL + CRITICAL
// ===============================================
void fib_critical(int n) {
    int *a = malloc(n * sizeof(int));
    a[0] = 0;
    a[1] = 1;

    double st = omp_get_wtime();
    omp_set_num_threads(2);

    #pragma omp parallel
    {
        int tid = omp_get_thread_num();

        if (tid == 0) {
            #pragma omp critical
            {
                printf("\n[CRITICAL] Compute Thread: %d\n", tid);
                for (int i = 2; i < n; i++)
                    a[i] = a[i - 2] + a[i - 1];
            }
        }

        // Wait for compute to finish
        #pragma omp barrier

        if (tid == 1) {
            #pragma omp critical
            {
                printf("[CRITICAL] Display Thread: %d\n", tid);
                printf("Fibonacci: ");
                for (int i = 0; i < n; i++)
                    printf("%d ", a[i]);
                printf("\n");
            }
        }
    }

    double et = omp_get_wtime();
    printf("[CRITICAL] Time: %lf ms\n", (et - st) * 1000);
    free(a);
}


// ===============================================
// MAIN DRIVER
// ===============================================
int main() {
    int n;
    printf("Enter Fibonacci terms: ");
    scanf("%d", &n);

    if (n < 2) {
        printf("Enter at least 2\n");
        return 0;
    }

    printf("\n========== USING SINGLE ==========\n");
    fib_single(n);

    printf("\n========== USING SECTIONS ==========\n");
    fib_sections(n);

    printf("\n========== USING CRITICAL ==========\n");
    fib_critical(n);

    return 0;
}
