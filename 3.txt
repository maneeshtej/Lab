//Using reduction
// #include <stdio.h>
// #include <omp.h>
// int main() {
//  long num_steps = 1000000000; // 1 billion steps for better accuracy
//  double step, x, sum = 0.0;
//  double start_time, end_time;
//  step = 1.0 / (double) num_steps;
//  start_time = omp_get_wtime(); // Start timing
//  #pragma omp parallel for private(x) reduction(+:sum)
//  for (long i = 0; i < num_steps; i++) {
//  x = (i + 0.5) * step;
//  sum += 4.0 / (1.0 + x * x);
//  }
//  double pi = step * sum;
//  end_time = omp_get_wtime(); // End timing
//  printf("Approximated Pi = %.15f\n", pi);
//  printf("Time taken = %f seconds\n", end_time - start_time);
//  return 0;
// }


// // Using Atomic :
// #include <stdio.h>
// #include <omp.h>
// int main() {
//  long num_steps = 100000000;
//  double step = 1.0 / (double)num_steps;
//  double sum = 0.0;
//  double start_time, end_time;
//  start_time = omp_get_wtime();
//  #pragma omp parallel
//  {
//  double x, local_sum = 0.0;
//  #pragma omp for
//  for (long i = 0; i < num_steps; i++) {
//  x = (i + 0.5) * step;
//  local_sum += 4.0 / (1.0 + x * x);
//  }
//  #pragma omp atomic
//  sum += local_sum;
//  }
//  double pi = step * sum;
//  end_time = omp_get_wtime();
//  printf("Parallel PI = %.15f\n", pi);
//  printf("Time taken: %f seconds\n", end_time - start_time);
//  return 0;
// }



// // Using Critical
#include <stdio.h>
#include <omp.h>
static long num_steps = 1000000;
double step;
int main() {
 int i;
 double x, pi = 0.0, sum = 0.0;
 step = 1.0 / (double)num_steps;
 double start_time = omp_get_wtime(); // Start timer
 #pragma omp parallel
 {
 double local_sum = 0.0;

 #pragma omp for
 for (i = 0; i < num_steps; i++) {
 x = (i + 0.5) * step;
 local_sum = 4.0 / (1.0 + x * x);
 // Use critical section to avoid race condition
 #pragma omp critical
 {
 sum += local_sum;
 }
 }
 }
 pi = step * sum;
 double end_time = omp_get_wtime(); // End timer
 printf("Computed value of Pi = %.15f\n", pi);
 printf("Time taken = %f seconds\n", end_time - start_time);
 return 0;
}



