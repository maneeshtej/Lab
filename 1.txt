// #include <stdio.h>
// #include <stdlib.h>
// #include <omp.h>
// int main() {
//  int n = 2000; // Large enough to see parallel benefit
//  double **matrix, *vector, *result;
//  int i, j;
//  // Allocate memory
//  matrix = (double **)malloc(n * sizeof(double *));
//  for (i = 0; i < n; i++)
//  matrix[i] = (double *)malloc(n * sizeof(double));
//  vector = (double *)malloc(n * sizeof(double));
//  result = (double *)malloc(n * sizeof(double));
//  // Initialize matrix and vector
//  for (i = 0; i < n; i++) {
//  vector[i] = 1.0;
//  for (j = 0; j < n; j++)
//  matrix[i][j] = 1.0;
//  }
//  // Sequential execution
//  double start = omp_get_wtime();
//  for (i = 0; i < n; i++) {
//  double sum = 0.0;
//  for (j = 0; j < n; j++)
//  sum += matrix[i][j] * vector[j];
//  result[i] = sum;
//  }
//  double end = omp_get_wtime();
//  printf("Sequential Time: %f seconds\n", end - start);
//  // Parallel execution
//  start = omp_get_wtime();
//  #pragma omp parallel for private(j) schedule(static)
//  for (i = 0; i < n; i++) {
//  double sum = 0.0;
//  for (j = 0; j < n; j++)
//  sum += matrix[i][j] * vector[j];
//  result[i] = sum;
//  }
//  end = omp_get_wtime();
//  printf("Parallel Time: %f seconds\n", end - start);
//  // Free memory
//  for (i = 0; i < n; i++)
//  free(matrix[i]);
//  free(matrix);
//  free(vector);
//  free(result);
//  return 0;
// }






#include <stdio.h>
#include <stdlib.h>
#include <omp.h>
int main() {
 int n = 2000; // Large enough to see parallel benefit
 double **matrix, *vector, *result;
 int i, j;
 // Allocate memory
 matrix = (double **)malloc(n * sizeof(double *));
 for (i = 0; i < n; i++)
 matrix[i] = (double *)malloc(n * sizeof(double));
 vector = (double *)malloc(n * sizeof(double));
 result = (double *)malloc(n * sizeof(double));
 // Initialize matrix and vector
 for (i = 0; i < n; i++) {
 vector[i] = 2.0;
 for (j = 0; j < n; j++)
 matrix[i][j] = 2.0;
 }
 // Sequential execution
 double start = omp_get_wtime();
 for (i = 0; i < n; i++) {
 double sum = 0.0;
 for (j = 0; j < n; j++)
 sum += matrix[i][j] * vector[j];
 result[i] = sum;
 }
 double end = omp_get_wtime();
 printf("Sequential Time: %f seconds\n", end - start);
 // Print first 10 values of result (Sequential)
 printf("Sequential result (first 10 values): ");
 for (i = 0; i < 10; i++)
 printf("%0.2f ", result[i]);
 printf("\n");
 // Parallel execution
 start = omp_get_wtime();
 #pragma omp parallel for private(j) schedule(static)
 for (i = 0; i < n; i++) {
 double sum = 0.0;
 for (j = 0; j < n; j++)
 sum += matrix[i][j] * vector[j];
 result[i] = sum;
 }
 end = omp_get_wtime();
 printf("Parallel Time: %f seconds\n", end - start);
 // Print first 10 values of result (Parallel)
 printf("Parallel result (first 10 values): ");
 for (i = 0; i < 10; i++)
 printf("%0.2f ", result[i]);
 printf("\n");
 // Free memory
 for (i = 0; i < n; i++)
 free(matrix[i]);
 free(matrix);
 free(vector);
 free(result);
 return 0;
}